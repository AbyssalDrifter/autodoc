import re
import os
import ast


def shift_docstring(docstring, indent):
    """
    Shifts the docstring by a specified number of spaces.
    
    Args:
        docstring (str): The docstring to be shifted.
        indent (int): The number of spaces to shift the docstring by.
    
    Returns:
        str: The shifted docstring. If the input docstring is None, it returns an empty string.
    """
    if docstring is None:
        return ''
    
    docstring = "\n".join(['"""', docstring, '"""'])
    lines = docstring.strip().split("\n")
    shifted_lines = [" " * indent + line for line in lines] #these docstrings are already shifted by 4 spaces
    shifted_docstring = "\n".join(shifted_lines) + "\n"
    
    return shifted_docstring


def remove_start_end_lines(docstrings):
    """
    Removes the start and end lines from a code string.
    
    Args:
        code_string (str): The code string from which start and end lines are to be removed.
    
    Returns:
        str: The cleaned code string with start and end lines removed.
    """
    # Define the pattern to match the start and end lines
    pattern = r'(^start$|^end$|^```python$|^```$|^(?!def|class)([a-zA-Z_]\w*)\s*\([^)]*\):\s*(\'\'\'[^\'\']*\'\'\'|"""[^"]*"""))'
    # Use regular expressions to remove the matched lines
    cleaned_code = re.sub(pattern, "", docstrings, flags=re.MULTILINE | re.DOTALL)

    return cleaned_code


def insert_docstrings(file_path, docstrings):
    """
    Inserts docstrings into a Python file at the appropriate locations.
    
    Args:
        file_path (str): The path to the Python file where docstrings are to be inserted.
        docstrings (str): The string of docstrings to be inserted.
    
    Note:
        The docstrings are first cleaned by removing the start and end lines. The function then parses 
        the cleaned docstrings into an abstract syntax tree (AST). It iterates over all nodes in the 
        AST, and for each class or function definition, it inserts the corresponding docstring into 
        the Python file.
    """
    docstrings = remove_start_end_lines(docstrings) #remove "start" and "end"- lines generated by gpt

    tree_doc = ast.parse(docstrings)
    for node_doc in ast.walk(tree_doc):         #iterate over all nodes in the docstring ast
        if isinstance(node_doc, (ast.ClassDef, ast.FunctionDef)):
            insert_1_docstring(node_doc, file_path) #insert docstring one by one into the code


def insert_1_docstring(node_doc, file_path):
    """
    Inserts a single docstring into a Python file.
    
    Args:
        node_doc (ast.AST): A node from the docstring AST.
        file_path (str): The path to the Python file where the docstring is to be inserted.
    
    Note:
        The function reads the Python file and parses it into an AST. It then iterates over all nodes 
        in the code AST. For each class or function definition, it checks if the name matches the name 
        of the docstring node. If a match is found, it gets the docstring from the docstring node and 
        checks if the code node already has a docstring. If it does, the old docstring is removed and 
        the new one is inserted. If it doesn't, the new docstring is inserted at the appropriate 
        location. The function then writes the modified code back to the Python file.
    """
    with open(file_path, "r") as file:
        code = file.read()
        file.seek(0)
        lines_code = file.readlines()
    tree_code = ast.parse(code)

    for node_code in ast.walk(tree_code):
        if isinstance(node_code, (ast.ClassDef, ast.FunctionDef)):
            try:
                if node_code.name == node_doc.name:
                    docstring = ast.get_docstring(node_doc)
                    if ast.get_docstring(node_code) is not None:
                        start = node_code.body[0].__dict__['lineno'] #start line of old docstring
                        end = node_code.body[0].__dict__['end_lineno'] #end line of old docstring
                        for i in range(end-start+1):
                            del lines_code[start-1] #delete old docstring
                        indent = node_code.body[0].col_offset
                        shifted_docstring = shift_docstring(docstring, indent)
                        lines_code.insert(start-1, shifted_docstring)
                    if ast.get_docstring(node_code) is None:
                        start = find_end_of_definition(lines_code, node_code) - 1
                        indent = node_code.body[0].col_offset
                        shifted_docstring = shift_docstring(docstring, indent)
                        lines_code.insert(start, shifted_docstring)
            except AttributeError:
                pass
        

    with open(file_path, "w") as file:
        file.truncate()
        file.write(''.join(lines_code))


def find_end_of_definition(code_lines, node):
    """
    Finds the end line of a class or function definition in a code file.
    
    Args:
        code_lines (list): The list of lines in the code file.
        node (ast.AST): The AST node representing the class or function definition.
    
    Returns:
        int: The line number of the end of the definition.
    """
    start_lno = node.__dict__['lineno']
    end_lno = node.body[0].lineno
    starting_text = code_lines[start_lno-1:end_lno-1]
    
    pattern = '(:\s*)$|(:\s*#.*$)'
    
    for i, line in enumerate(starting_text, start=1):
        matches = re.search(pattern, line, re.M)
        if matches:
            break
    
    return start_lno + i